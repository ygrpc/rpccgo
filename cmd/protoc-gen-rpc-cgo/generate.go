package main

import (
	"fmt"
	"sort"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	rpcRuntimePkg           = protogen.GoImportPath("github.com/ygrpc/rpccgo/rpcruntime")
	protoPackage            = protogen.GoImportPath("google.golang.org/protobuf/proto")
	unsafePackage           = protogen.GoImportPath("unsafe")
	syncAtomicPkg           = protogen.GoImportPath("sync/atomic")
	cgoCommonHeaderBasename = "ygrpc_cgo_common.h"
)

func generateCgoCommonHeader(gen *protogen.Plugin) *protogen.GeneratedFile {
	h := gen.NewGeneratedFile(cgoCommonHeaderBasename, "")

	h.P("// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.")
	h.P()
	h.P("#ifndef YGRPC_CGO_COMMON_H")
	h.P("#define YGRPC_CGO_COMMON_H")
	h.P()
	h.P("#include <stdint.h>")
	h.P("#include <stddef.h>")
	h.P("#include <stdlib.h>")
	h.P()
	h.P("typedef void (*FreeFunc)(void*);")
	h.P()
	h.P("typedef enum {")
	h.P("    YGRPC_PROTOCOL_UNSET = 0,")
	h.P("    YGRPC_PROTOCOL_GRPC = 1,")
	h.P("    YGRPC_PROTOCOL_CONNECTRPC = 2,")
	h.P("} YgrpcProtocol;")
	h.P()

	h.P("extern void Ygrpc_Free(void* ptr);")
	h.P("extern uint64_t Ygrpc_SetProtocol(int protocol);")
	h.P("extern uint64_t Ygrpc_GetErrorMsg(uint64_t error_id, void** msg_ptr, int* msg_len, FreeFunc* msg_free);")
	h.P()

	h.P("static inline void call_free_func(FreeFunc fn, void* ptr) {")

	h.P("    if (fn) fn(ptr);")
	h.P("}")
	h.P()
	h.P("typedef void (*OnReadBytesFunc)(uint64_t call_id, void* resp_ptr, int resp_len, FreeFunc resp_free);")
	h.P("typedef void (*OnDoneFunc)(uint64_t call_id, uint64_t error_id);")
	h.P()
	h.P(
		"static inline void call_on_read_bytes(void* fn, uint64_t call_id, void* resp_ptr, int resp_len, FreeFunc resp_free) {",
	)
	h.P("    if(fn) ((OnReadBytesFunc)fn)(call_id, resp_ptr, resp_len, resp_free);")
	h.P("}")
	h.P()
	h.P("static inline void call_on_done(void* fn, uint64_t call_id, uint64_t error_id) {")
	h.P("    if(fn) ((OnDoneFunc)fn)(call_id, error_id);")
	h.P("}")
	h.P()
	h.P("#endif")

	return h
}

func generateMainFile(gen *protogen.Plugin) *protogen.GeneratedFile {
	g := gen.NewGeneratedFile("main.go", "")

	g.P("// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.")
	g.P()
	g.P("package main")
	g.P()

	g.P("/*")
	g.P("#include \"", cgoCommonHeaderBasename, "\"")
	g.P("*/")
	g.P("import \"C\"")
	g.P()

	g.P("import (")
	g.P("    \"unsafe\"")
	g.P("    \"github.com/ygrpc/rpccgo/rpcruntime\"")
	g.P(")")
	g.P()

	g.P("//export Ygrpc_Free")
	g.P("func Ygrpc_Free(ptr unsafe.Pointer) {")
	g.P("    C.free(ptr)")
	g.P("}")
	g.P()

	g.P("//export Ygrpc_SetProtocol")
	g.P("func Ygrpc_SetProtocol(protocol C.int) C.uint64_t {")
	g.P("    switch int(protocol) {")
	g.P("    case 0:")
	g.P("        rpcruntime.ClearDefaultProtocol()")
	g.P("        return 0")
	g.P("    case 1:")
	g.P("        if err := rpcruntime.SetDefaultProtocol(rpcruntime.ProtocolGrpc); err != nil {")
	g.P("            return C.uint64_t(rpcruntime.StoreError(err))")
	g.P("        }")
	g.P("        return 0")
	g.P("    case 2:")
	g.P("        if err := rpcruntime.SetDefaultProtocol(rpcruntime.ProtocolConnectRPC); err != nil {")
	g.P("            return C.uint64_t(rpcruntime.StoreError(err))")
	g.P("        }")
	g.P("        return 0")
	g.P("    default:")
	g.P("        return C.uint64_t(rpcruntime.StoreError(rpcruntime.ErrUnknownProtocol))")
	g.P("    }")
	g.P("}")
	g.P()

	g.P("//export Ygrpc_GetErrorMsg")
	g.P(
		"func Ygrpc_GetErrorMsg(errorID C.uint64_t, msgPtr *unsafe.Pointer, msgLen *C.int, msgFree *C.FreeFunc) C.uint64_t {",
	)
	g.P("    msg, ok := rpcruntime.GetErrorMsgBytes(uint64(errorID))")
	g.P("    if !ok {")
	g.P("        return 1")
	g.P("    }")
	g.P("    if len(msg) == 0 {")
	g.P("        *msgPtr = nil")
	g.P("        *msgLen = 0")
	g.P("        *msgFree = nil")
	g.P("        return 0")
	g.P("    }")
	g.P("    buf := C.CBytes(msg)")
	g.P("    *msgPtr = buf")
	g.P("    *msgLen = C.int(len(msg))")
	g.P("    *msgFree = (C.FreeFunc)(C.Ygrpc_Free)")
	g.P("    return 0")
	g.P("}")
	g.P()

	g.P("func main() {}")

	return g
}

func generateCgoFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_cgo.go"
	g := gen.NewGeneratedFile(filename, "")

	fileOpts := getFileOptions(file)

	g.P("// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.")
	g.P("//")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package main")
	g.P()

	g.P("/*")
	g.P("#include \"", cgoCommonHeaderBasename, "\"")
	g.P()

	// Native streaming callbacks are method-specific because the response fields are flattened.
	for _, service := range file.Services {
		for _, method := range service.Methods {
			isClientStreaming := method.Desc.IsStreamingClient()
			isServerStreaming := method.Desc.IsStreamingServer()
			if !isServerStreaming {
				continue
			}
			if isClientStreaming && isServerStreaming {
				// bidi streaming
			}
			methodOpts := getMethodOptions(method, fileOpts)
			if !shouldGenerateNative(methodOpts.NativeMode) {
				continue
			}
			if !isMessageFlat(method.Input) || !isMessageFlat(method.Output) {
				continue
			}
			emitNativeOnReadWrapper(g, service.GoName, method.GoName, method.Output)
		}
	}

	g.P("*/")
	g.P("import \"C\"")
	g.P()

	for _, service := range file.Services {
		generateService(g, file, service, fileOpts)
	}

	return g
}

func fieldToCgoNativeCallbackArgs(field *protogen.Field) []string {
	name := strings.ToLower(string(field.Desc.Name()))
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return []string{"int8_t " + name}
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return []string{"int32_t " + name}
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return []string{"int64_t " + name}
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return []string{"uint32_t " + name}
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return []string{"uint64_t " + name}
	case protoreflect.FloatKind:
		return []string{"float " + name}
	case protoreflect.DoubleKind:
		return []string{"double " + name}
	case protoreflect.StringKind, protoreflect.BytesKind:
		return []string{
			"void* " + name + "_ptr",
			"int " + name + "_len",
			"FreeFunc " + name + "_free",
		}
	default:
		return []string{"int64_t " + name}
	}
}

func emitNativeOnReadWrapper(g *protogen.GeneratedFile, serviceName, methodName string, respMsg *protogen.Message) {
	wrapper := fmt.Sprintf("call_on_read_native_%s_%s", serviceName, methodName)
	typedefName := fmt.Sprintf("OnReadNativeFunc_%s_%s", serviceName, methodName)

	args := []string{}
	fields := append([]*protogen.Field(nil), respMsg.Fields...)
	sort.Slice(fields, func(i, j int) bool { return fields[i].Desc.Number() < fields[j].Desc.Number() })
	for _, field := range fields {
		args = append(args, fieldToCgoNativeCallbackArgs(field)...)
	}

	g.P("typedef void (*", typedefName, ")(")
	g.P("    uint64_t call_id")
	for _, a := range args {
		g.P("    , ", a)
	}
	g.P(");")
	g.P("static inline void ", wrapper, "(void* fn, uint64_t call_id")
	for _, a := range args {
		g.P("    , ", a)
	}
	g.P(") {")
	g.P("    ((", typedefName, ")fn)(")
	g.P("        call_id")
	for _, field := range fields {
		name := strings.ToLower(string(field.Desc.Name()))
		switch field.Desc.Kind() {
		case protoreflect.StringKind, protoreflect.BytesKind:
			g.P("        , ", name, "_ptr, ", name, "_len, ", name, "_free")
		default:
			g.P("        , ", name)
		}
	}
	g.P("    );")
	g.P("}")
	g.P()
}

func generateService(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	fileOpts CgoOptions,
) {
	for _, method := range service.Methods {
		methodOpts := getMethodOptions(method, fileOpts)
		generateMethod(g, file, service, method, methodOpts)
	}
}

func generateMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts MethodCgoOptions,
) {
	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	switch {
	case !isClientStreaming && !isServerStreaming:
		generateUnaryMethod(g, file, service, method, opts)
	case isClientStreaming && !isServerStreaming:
		generateClientStreamingMethod(g, file, service, method, opts)
	case !isClientStreaming && isServerStreaming:
		generateServerStreamingMethod(g, file, service, method, opts)
	default:
		generateBidiStreamingMethod(g, file, service, method, opts)
	}
}
