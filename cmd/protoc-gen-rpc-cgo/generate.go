package main

import (
	"fmt"
	"sort"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	rpcRuntimePkg           = protogen.GoImportPath("github.com/ygrpc/rpccgo/rpcruntime")
	protoPackage            = protogen.GoImportPath("google.golang.org/protobuf/proto")
	unsafePackage           = protogen.GoImportPath("unsafe")
	syncAtomicPkg           = protogen.GoImportPath("sync/atomic")
	cgoCommonHeaderBasename = "ygrpc_cgo_common.h"
)

func generateCgoCommonHeader(gen *protogen.Plugin) *protogen.GeneratedFile {
	h := gen.NewGeneratedFile(cgoCommonHeaderBasename, "")

	h.P("// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.")
	h.P()
	h.P("#ifndef YGRPC_CGO_COMMON_H")
	h.P("#define YGRPC_CGO_COMMON_H")
	h.P()
	h.P("#include <stdint.h>")
	h.P("#include <stddef.h>")
	h.P("#include <stdlib.h>")
	h.P()
	h.P("typedef void (*FreeFunc)(void*);")
	h.P()

	h.P("extern void Ygrpc_Free(void* ptr);")
	h.P("extern int Ygrpc_GetErrorMsg(int error_id, void** msg_ptr, int* msg_len, FreeFunc* msg_free);")
	h.P()

	h.P("static inline void call_free_func(FreeFunc fn, void* ptr) {")

	h.P("    if (fn) fn(ptr);")
	h.P("}")
	h.P()
	h.P("typedef void (*OnReadBytesFunc)(void* resp_ptr, int resp_len, FreeFunc resp_free, void* user_data);")
	h.P("typedef void (*OnDoneFunc)(int error_id, void* user_data);")
	h.P()
	h.P(
		"static inline void call_on_read_bytes(void* fn, void* resp_ptr, int resp_len, FreeFunc resp_free, void* user_data) {",
	)
	h.P("    if(fn) ((OnReadBytesFunc)fn)(resp_ptr, resp_len, resp_free, user_data);")
	h.P("}")
	h.P()
	h.P("static inline void call_on_done(void* fn, int error_id, void* user_data) {")
	h.P("    if(fn) ((OnDoneFunc)fn)(error_id, user_data);")
	h.P("}")
	h.P()
	h.P("#endif")

	return h
}

func generateMainFile(gen *protogen.Plugin) *protogen.GeneratedFile {
	g := gen.NewGeneratedFile("main.go", "")

	g.P("// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.")
	g.P()
	g.P("package main")
	g.P()

	g.P("/*")
	g.P("#include \"", cgoCommonHeaderBasename, "\"")
	g.P("*/")
	g.P("import \"C\"")
	g.P()

	g.P("import (")
	g.P("    \"unsafe\"")
	g.P("    \"github.com/ygrpc/rpccgo/rpcruntime\"")
	g.P(")")
	g.P()

	g.P("//export Ygrpc_Free")
	g.P("func Ygrpc_Free(ptr unsafe.Pointer) {")
	g.P("    C.free(ptr)")
	g.P("}")
	g.P()

	g.P("//export Ygrpc_GetErrorMsg")
	g.P("func Ygrpc_GetErrorMsg(errorID C.int, msgPtr *unsafe.Pointer, msgLen *C.int, msgFree *C.FreeFunc) C.int {")
	g.P("    msg, ok := rpcruntime.GetErrorMsgBytes(int64(errorID))")
	g.P("    if !ok {")
	g.P("        return 1")
	g.P("    }")
	g.P("    if len(msg) == 0 {")
	g.P("        *msgPtr = nil")
	g.P("        *msgLen = 0")
	g.P("        *msgFree = nil")
	g.P("        return 0")
	g.P("    }")
	g.P("    buf := C.CBytes(msg)")
	g.P("    *msgPtr = buf")
	g.P("    *msgLen = C.int(len(msg))")
	g.P("    *msgFree = (C.FreeFunc)(C.Ygrpc_Free)")
	g.P("    return 0")
	g.P("}")
	g.P()

	g.P("func main() {}")

	return g
}

func generateCgoFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_cgo.go"
	g := gen.NewGeneratedFile(filename, "")

	fileOpts := getFileOptions(file)

	g.P("// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.")
	g.P("//")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package main")
	g.P()

	g.P("/*")
	g.P("#include \"", cgoCommonHeaderBasename, "\"")
	g.P()

	// Native streaming callbacks are method-specific because the response fields are flattened.
	for _, service := range file.Services {
		for _, method := range service.Methods {
			isClientStreaming := method.Desc.IsStreamingClient()
			isServerStreaming := method.Desc.IsStreamingServer()
			if !isServerStreaming {
				continue
			}
			if isClientStreaming && isServerStreaming {
				// bidi streaming
			}
			methodOpts := getMethodOptions(method, fileOpts)
			if !shouldGenerateNative(methodOpts.NativeMode) {
				continue
			}
			if !isMessageFlat(method.Input) || !isMessageFlat(method.Output) {
				continue
			}
			emitNativeOnReadWrapper(g, service.GoName, method.GoName, method.Output)
		}
	}

	g.P("*/")
	g.P("import \"C\"")
	g.P()

	for _, service := range file.Services {
		generateService(g, file, service, fileOpts)
	}

	return g
}

func fieldToCgoNativeCallbackArgs(field *protogen.Field) []string {
	name := strings.ToLower(string(field.Desc.Name()))
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return []string{"int8_t " + name}
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return []string{"int32_t " + name}
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return []string{"int64_t " + name}
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return []string{"uint32_t " + name}
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return []string{"uint64_t " + name}
	case protoreflect.FloatKind:
		return []string{"float " + name}
	case protoreflect.DoubleKind:
		return []string{"double " + name}
	case protoreflect.StringKind, protoreflect.BytesKind:
		return []string{
			"void* " + name + "_ptr",
			"int " + name + "_len",
			"FreeFunc " + name + "_free",
		}
	default:
		return []string{"int64_t " + name}
	}
}

func emitNativeOnReadWrapper(g *protogen.GeneratedFile, serviceName, methodName string, respMsg *protogen.Message) {
	wrapper := fmt.Sprintf("call_on_read_native_%s_%s", serviceName, methodName)
	typedefName := fmt.Sprintf("OnReadNativeFunc_%s_%s", serviceName, methodName)

	args := []string{}
	fields := append([]*protogen.Field(nil), respMsg.Fields...)
	sort.Slice(fields, func(i, j int) bool { return fields[i].Desc.Number() < fields[j].Desc.Number() })
	for _, field := range fields {
		args = append(args, fieldToCgoNativeCallbackArgs(field)...)
	}

	g.P("typedef void (*", typedefName, ")(")
	if len(args) == 0 {
		g.P("    void* user_data")
	} else {
		for _, a := range args {
			g.P("    ", a, ",")
		}
		g.P("    void* user_data")
	}
	g.P(");")
	g.P("static inline void ", wrapper, "(void* fn, void* user_data")
	for _, a := range args {
		g.P("    , ", a)
	}
	g.P(") {")
	g.P("    ((", typedefName, ")fn)(")
	if len(args) == 0 {
		g.P("        user_data")
	} else {
		for _, field := range fields {
			name := strings.ToLower(string(field.Desc.Name()))
			switch field.Desc.Kind() {
			case protoreflect.StringKind, protoreflect.BytesKind:
				g.P("        ", name, "_ptr, ", name, "_len, ", name, "_free,")
			default:
				g.P("        ", name, ",")
			}
		}
		g.P("        user_data")
	}
	g.P("    );")
	g.P("}")
	g.P()
}

func generateService(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	fileOpts CgoOptions,
) {
	for _, method := range service.Methods {
		methodOpts := getMethodOptions(method, fileOpts)
		generateMethod(g, file, service, method, methodOpts)
	}
}

func generateMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts MethodCgoOptions,
) {
	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	switch {
	case !isClientStreaming && !isServerStreaming:
		generateUnaryMethod(g, file, service, method, opts)
	case isClientStreaming && !isServerStreaming:
		generateClientStreamingMethod(g, file, service, method, opts)
	case !isClientStreaming && isServerStreaming:
		generateServerStreamingMethod(g, file, service, method, opts)
	default:
		generateBidiStreamingMethod(g, file, service, method, opts)
	}
}
