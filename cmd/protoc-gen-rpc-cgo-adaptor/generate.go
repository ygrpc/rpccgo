package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage = protogen.GoImportPath("context")
	rpcRuntimePkg  = protogen.GoImportPath("github.com/ygrpc/rpccgo/rpcruntime")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	connectPackage = protogen.GoImportPath("connectrpc.com/connect")
)

func generateFile(gen *protogen.Plugin, file *protogen.File, opts GeneratorOptions) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_cgo_adaptor.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.")
	g.P("//")
	g.P("// source: ", file.Desc.Path())
	g.P("// protocols: ", strings.Join(protocolOptionStrings(opts.Protocols), ","))
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate imports by referencing them in generated code.

	for _, service := range file.Services {
		generateService(g, file, service, opts)
	}

	return g
}

func generateService(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	opts GeneratorOptions,
) {
	serviceName := string(service.Desc.FullName())

	// Generate constants for service name and full method names.
	g.P("// ", service.GoName, " adaptor constants.")
	g.P("const (")
	g.P("    ", service.GoName, "_ServiceName = ", fmt.Sprintf("%q", serviceName))
	for _, method := range service.Methods {
		fullMethod := fmt.Sprintf("/%s/%s", serviceName, method.Desc.Name())
		g.P("    ", service.GoName, "_", method.GoName, "_FullMethod = ", fmt.Sprintf("%q", fullMethod))
	}
	g.P(")")
	g.P()

	generateServiceLookupHelper(g, file, service, opts)

	// Generate stream adaptor types for gRPC streaming methods.
	// Connect streaming uses rpcruntime helpers (NewClientStream, etc.) instead of adaptor types.
	if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) {
		for _, method := range service.Methods {
			isClientStreaming := method.Desc.IsStreamingClient()
			isServerStreaming := method.Desc.IsStreamingServer()
			if isClientStreaming || isServerStreaming {
				generateStreamAdaptorType(g, file, service, method, "grpc")
			}
		}
	}

	// Generate adaptor functions for each method.
	for _, method := range service.Methods {
		generateMethod(g, file, service, method, opts)
	}
}

func generateMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	// Determine streaming type.
	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	if !isClientStreaming && !isServerStreaming {
		// Unary method.
		generateUnaryMethod(g, file, service, method, opts)
	} else if isClientStreaming && !isServerStreaming {
		// Client-streaming method.
		generateClientStreamingMethod(g, file, service, method, opts)
	} else if !isClientStreaming && isServerStreaming {
		// Server-streaming method.
		generateServerStreamingMethod(g, file, service, method, opts)
	} else {
		// Bidi-streaming method.
		generateBidiStreamingMethod(g, file, service, method, opts)
	}
}

func generateUnaryMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	funcName := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)

	g.P("// ", funcName, " calls ", method.Desc.FullName(), " via the registered handler.")
	g.P(
		"func ",
		funcName,
		"(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		", req *",
		reqType,
		") (*",
		respType,
		", error) {",
	)

	generateUnaryDispatch(g, file, service, method, opts)

	g.P("}")
	g.P()
}

func generateUnaryDispatch(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	lookupFuncName := service.GoName + "_lookupHandler"
	grpcServerIface := service.GoName + "Server"

	if len(opts.Protocols) == 1 {
		g.P("    _, h, err := ", lookupFuncName, "(ctx)")
		g.P("    if err != nil {")
		g.P("        return nil, err")
		g.P("    }")
		if opts.Protocols[0] == ProtocolOptionGrpc {
			g.P("    svc, ok := h.(", grpcServerIface, ")")
			g.P("    if !ok {")
			g.P("        return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
			g.P("    }")
			g.P("    return svc.", method.GoName, "(ctx, req)")
		} else {
			connectHandlerIface := connectHandlerAssertionType(g, service, method, opts)
			g.P("    svc, ok := h.(", connectHandlerIface, ")")
			g.P("    if !ok {")
			g.P("        return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
			g.P("    }")
			g.P("    return svc.", method.GoName, "(ctx, req)")
		}
		return
	}

	connectHandlerIface := connectHandlerAssertionType(g, service, method, opts)

	g.P("    protocol, h, err := ", lookupFuncName, "(ctx)")
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    switch protocol {")

	if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) {
		g.P("    case ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), ":")
		g.P("        svc, ok := h.(", grpcServerIface, ")")
		g.P("        if !ok {")
		g.P("            return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        return svc.", method.GoName, "(ctx, req)")
	}

	if supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		g.P("    case ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), ":")
		g.P("        svc, ok := h.(", connectHandlerIface, ")")
		g.P("        if !ok {")
		g.P("            return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        return svc.", method.GoName, "(ctx, req)")
	}

	g.P("    default:")
	g.P("        return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
	g.P("    }")
}

func generateServiceLookupHelper(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	opts GeneratorOptions,
) {
	lookupFuncName := service.GoName + "_lookupHandler"
	serviceConstName := service.GoName + "_ServiceName"

	g.P("// ", lookupFuncName, " selects a protocol and looks up the registered handler.")
	g.P("//")
	g.P("// Selection rules:")
	g.P("// - If ctx explicitly carries a protocol, only that protocol is attempted (no fallback).")
	g.P(
		"// - Otherwise, protocols are tried in the configured order: ",
		strings.Join(protocolOptionStrings(opts.Protocols), ","),
	)
	g.P(
		"func ",
		lookupFuncName,
		"(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		") (",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("Protocol")),
		", any, error) {",
	)
	g.P("    protocol, hasProtocol := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolFromContext")), "(ctx)")
	g.P("    if hasProtocol {")
	if len(opts.Protocols) == 1 {
		only := opts.Protocols[0]
		if only == ProtocolOptionGrpc {
			g.P("        if protocol != ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), " {")
			g.P("            return protocol, nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
			g.P("        }")
			g.P(
				"        h, ok := ",
				g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
				"(",
				serviceConstName,
				")",
			)
			g.P("        if !ok {")
			g.P(
				"            return protocol, nil, ",
				g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")),
			)
			g.P("        }")
			g.P("        return protocol, h, nil")
		} else {
			g.P("        if protocol != ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), " {")
			g.P("            return protocol, nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
			g.P("        }")
			g.P("        h, ok := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")), "(", serviceConstName, ")")
			g.P("        if !ok {")
			g.P("            return protocol, nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
			g.P("        }")
			g.P("        return protocol, h, nil")
		}
	} else {
		g.P("        switch protocol {")
		if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) {
			g.P("        case ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), ":")
			g.P("            h, ok := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")), "(", serviceConstName, ")")
			g.P("            if !ok {")
			g.P("                return protocol, nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
			g.P("            }")
			g.P("            return protocol, h, nil")
		}
		if supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
			g.P("        case ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), ":")
			g.P("            h, ok := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")), "(", serviceConstName, ")")
			g.P("            if !ok {")
			g.P("                return protocol, nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
			g.P("            }")
			g.P("            return protocol, h, nil")
		}
		g.P("        default:")
		g.P("            return protocol, nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
		g.P("        }")
	}
	g.P("    }")
	g.P()
	if len(opts.Protocols) == 1 {
		only := opts.Protocols[0]
		if only == ProtocolOptionGrpc {
			g.P(
				"    h, ok := ",
				g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
				"(",
				serviceConstName,
				")",
			)
			g.P("    if !ok {")
			g.P("        return \"\", nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
			g.P("    }")
			g.P("    return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), ", h, nil")
		} else {
			g.P("    h, ok := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")), "(", serviceConstName, ")")
			g.P("    if !ok {")
			g.P("        return \"\", nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
			g.P("    }")
			g.P("    return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), ", h, nil")
		}
	} else {
		g.P("    // Fallback: try protocols in configured order.")
		for _, p := range opts.Protocols {
			if p == ProtocolOptionGrpc {
				g.P(
					"    if h, ok := ",
					g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
					"(",
					serviceConstName,
					"); ok {",
				)
				g.P("        return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), ", h, nil")
				g.P("    }")
			} else if p == ProtocolOptionConnectRPC {
				g.P("    if h, ok := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")), "(", serviceConstName, "); ok {")
				g.P("        return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), ", h, nil")
				g.P("    }")
			}
		}
		g.P("    return \"\", nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	}
	g.P("}")
	g.P()
}

func connectHandlerAssertionType(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) string {
	_ = service
	_ = opts

	ctxType := g.QualifiedGoIdent(contextPackage.Ident("Context"))
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)

	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	if !isClientStreaming && !isServerStreaming {
		return fmt.Sprintf(
			"interface{ %s(%s, *%s) (*%s, error) }",
			method.GoName,
			ctxType,
			reqType,
			respType,
		)
	} else if isClientStreaming && !isServerStreaming {
		clientStreamType := g.QualifiedGoIdent(connectPackage.Ident("ClientStream"))
		return fmt.Sprintf(
			"interface{ %s(%s, *%s[%s]) (*%s, error) }",
			method.GoName,
			ctxType,
			clientStreamType,
			reqType,
			respType,
		)
	} else if !isClientStreaming && isServerStreaming {
		serverStreamType := g.QualifiedGoIdent(connectPackage.Ident("ServerStream"))
		return fmt.Sprintf(
			"interface{ %s(%s, *%s, *%s[%s]) error }",
			method.GoName,
			ctxType,
			reqType,
			serverStreamType,
			respType,
		)
	} else {
		bidiStreamType := g.QualifiedGoIdent(connectPackage.Ident("BidiStream"))
		return fmt.Sprintf(
			"interface{ %s(%s, *%s[%s, %s]) error }",
			method.GoName,
			ctxType,
			bidiStreamType,
			reqType,
			respType,
		)
	}
}

func protocolOptionStrings(protocols []ProtocolOption) []string {
	out := make([]string, 0, len(protocols))
	for _, p := range protocols {
		out = append(out, string(p))
	}
	return out
}

func generateClientStreamingMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	funcPrefix := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	lookupFuncName := service.GoName + "_lookupHandler"
	grpcServerIface := service.GoName + "Server"
	connectHandlerIface := ""
	if supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		connectHandlerIface = connectHandlerAssertionType(g, service, method, opts)
	}

	g.P("// ", funcPrefix, " client-streaming adaptor functions.")
	g.P("// These use a staged API: Start, Send, Finish.")
	g.P()

	// Start function
	g.P("// ", funcPrefix, "Start initializes a client-streaming call and returns a stream handle.")
	g.P("func ", funcPrefix, "Start(ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")), ") (uint64, error) {")
	g.P("    protocol, h, err := ", lookupFuncName, "(ctx)")
	g.P("    if err != nil {")
	g.P("        return 0, err")
	g.P("    }")
	g.P(
		"    handle, childCtx, _ := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")),
		"(ctx, protocol)",
	)
	g.P(
		"    session := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")),
		"(handle)",
	)
	g.P("    if session == nil {")
	g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrInvalidStreamHandle")))
	g.P("    }")
	g.P()

	if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) &&
		supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		g.P("    if protocol == ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), " {")
		g.P("        svc, ok := h.(", grpcServerIface, ")")
		g.P("        if !ok {")
		g.P("            return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P(
			"        adaptorStream := &",
			unexport(service.GoName+"_"+method.GoName+"Server"),
			"Adaptor{session: session}",
		)
		g.P("        session.SetHandlerState(adaptorStream)")
		g.P("        go func() {")
		g.P("            err := svc.", method.GoName, "(adaptorStream)")
		g.P(
			"            ",
			g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")),
			"(handle, adaptorStream.lastResp, err)",
		)
		g.P("        }()")
		g.P("    } else if protocol == ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), " {")
		g.P("        svc, ok := h.(", connectHandlerIface, ")")
		g.P("        if !ok {")
		g.P("            return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
		g.P(
			"        connectStream := ",
			g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewClientStream")),
			"[",
			reqType,
			"](conn)",
		)
		g.P("        go func() {")
		g.P("            resp, err := svc.", method.GoName, "(childCtx, connectStream)")
		g.P("            ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")), "(handle, resp, err)")
		g.P("        }()")
		g.P("    } else {")
		g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
		g.P("    }")
	} else if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) {
		g.P("    svc, ok := h.(", grpcServerIface, ")")
		g.P("    if !ok {")
		g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("    }")
		g.P("    adaptorStream := &", unexport(service.GoName+"_"+method.GoName+"Server"), "Adaptor{session: session}")
		g.P("    session.SetHandlerState(adaptorStream)")
		g.P("    go func() {")
		g.P("        err := svc.", method.GoName, "(adaptorStream)")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")), "(handle, adaptorStream.lastResp, err)")
		g.P("    }()")
	} else {
		g.P("    svc, ok := h.(", connectHandlerIface, ")")
		g.P("    if !ok {")
		g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("    }")
		g.P("    conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
		g.P("    connectStream := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewClientStream")), "[", reqType, "](conn)")
		g.P("    go func() {")
		g.P("        resp, err := svc.", method.GoName, "(childCtx, connectStream)")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")), "(handle, resp, err)")
		g.P("    }()")
	}

	g.P()
	g.P("    _ = childCtx // Used in goroutine")
	g.P("    return uint64(handle), nil")
	g.P("}")
	g.P()

	// Send function
	g.P("// ", funcPrefix, "Send sends a request message to the stream.")
	g.P("func ", funcPrefix, "Send(streamHandle uint64, req *", reqType, ") error {")
	g.P(
		"    return ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("SendToStream")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle), req)",
	)
	g.P("}")
	g.P()

	// Finish function
	g.P("// ", funcPrefix, "Finish closes the send-side and returns the final response.")
	g.P("func ", funcPrefix, "Finish(streamHandle uint64) (*", respType, ", error) {")
	g.P(
		"    resp, err := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishClientStream")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle))",
	)
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    if resp == nil {")
	g.P("        return nil, nil")
	g.P("    }")
	g.P("    return resp.(*", respType, "), nil")
	g.P("}")
	g.P()
}

func generateClientStreamStartGrpc(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
	grpcServerIface := service.GoName + "Server"
	streamIface := service.GoName + "_" + method.GoName + "Server"

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", grpcServerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create adaptor stream and start handler goroutine")
	g.P(indent, "adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
	g.P(indent, "session.SetHandlerState(adaptorStream)")
	g.P(indent, "go func() {")
	g.P(indent, "    err := svc.", method.GoName, "(adaptorStream)")
	g.P(
		indent,
		"    ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")),
		"(handle, adaptorStream.lastResp, err)",
	)
	g.P(indent, "}()")
}

func generateClientStreamStartConnect(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
	connectHandlerIface := service.GoName + "Handler"
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", connectHandlerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create Connect stream using rpcruntime helper")
	g.P(indent, "conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
	g.P(
		indent,
		"connectStream := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewClientStream")),
		"[",
		reqType,
		"](conn)",
	)
	g.P(indent, "go func() {")
	g.P(indent, "    resp, err := svc.", method.GoName, "(childCtx, connectStream)")
	g.P(indent, "    ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")), "(handle, resp, err)")
	g.P(indent, "}()")
}

func unexport(s string) string {
	if len(s) == 0 {
		return s
	}
	return string(s[0]+'a'-'A') + s[1:]
}

func generateServerStreamingMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	// Server streaming uses callback API: onRead, onDone
	funcName := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	lookupFuncName := service.GoName + "_lookupHandler"
	grpcServerIface := service.GoName + "Server"
	connectHandlerIface := ""
	if supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		connectHandlerIface = connectHandlerAssertionType(g, service, method, opts)
	}

	g.P("// ", funcName, " calls ", method.Desc.FullName(), " via the registered handler.")
	g.P("//")
	g.P("// This is a server-streaming method. Results are delivered via callbacks:")
	g.P("// - onRead is called for each response message; return false to stop receiving.")
	g.P("// - onDone is called exactly once when the stream ends or fails.")
	g.P(
		"func ",
		funcName,
		"(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		", req *",
		reqType,
		", onRead func(*",
		respType,
		") bool, onDone func(error)) error {",
	)

	g.P("    protocol, h, err := ", lookupFuncName, "(ctx)")
	g.P("    if err != nil {")
	g.P("        onDone(err)")
	g.P("        return err")
	g.P("    }")

	g.P("    handle, _, _ := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")), "(ctx, protocol)")
	g.P("    session := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")), "(handle)")
	g.P("    if session == nil {")
	g.P("        onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrInvalidStreamHandle")), ")")
	g.P("        return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrInvalidStreamHandle")))
	g.P("    }")
	g.P("    session.SetCallbacks(func(resp any) bool { return onRead(resp.(*", respType, ")) }, onDone)")
	g.P()

	streamIface := service.GoName + "_" + method.GoName + "Server"

	if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) &&
		supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		g.P("    if protocol == ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), " {")
		g.P("        svc, ok := h.(", grpcServerIface, ")")
		g.P("        if !ok {")
		g.P("            ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("            onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")), ")")
		g.P("            return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
		g.P("        err = svc.", method.GoName, "(req, adaptorStream)")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        onDone(err)")
		g.P("        return err")
		g.P("    } else if protocol == ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), " {")
		g.P("        svc, ok := h.(", connectHandlerIface, ")")
		g.P("        if !ok {")
		g.P("            ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("            onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")), ")")
		g.P("            return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
		g.P(
			"        connectStream := ",
			g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewServerStream")),
			"[",
			respType,
			"](conn)",
		)
		g.P("        err = svc.", method.GoName, "(ctx, req, connectStream)")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        onDone(err)")
		g.P("        return err")
		g.P("    } else {")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")), ")")
		g.P("        return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
		g.P("    }")
	} else if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) {
		g.P("    svc, ok := h.(", grpcServerIface, ")")
		g.P("    if !ok {")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")), ")")
		g.P("        return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("    }")
		g.P("    adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
		g.P("    err = svc.", method.GoName, "(req, adaptorStream)")
		g.P("    ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("    onDone(err)")
		g.P("    return err")
	} else {
		g.P("    svc, ok := h.(", connectHandlerIface, ")")
		g.P("    if !ok {")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")), ")")
		g.P("        return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("    }")
		g.P("    conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
		g.P("    connectStream := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewServerStream")), "[", respType, "](conn)")
		g.P("    err = svc.", method.GoName, "(ctx, req, connectStream)")
		g.P("    ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("    onDone(err)")
		g.P("    return err")
	}

	g.P("}")
	g.P()
}

func generateBidiStreamingMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	funcPrefix := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	lookupFuncName := service.GoName + "_lookupHandler"
	grpcServerIface := service.GoName + "Server"
	connectHandlerIface := ""
	if supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		connectHandlerIface = connectHandlerAssertionType(g, service, method, opts)
	}

	g.P("// ", funcPrefix, " bidi-streaming adaptor functions.")
	g.P("// These use a combined staged + callback API: Start, Send, CloseSend + receive callbacks.")
	g.P()

	// Start function
	g.P("// ", funcPrefix, "Start initializes a bidi-streaming call and returns a stream handle.")
	g.P("// Provide onRead and onDone callbacks to receive response messages.")
	g.P(
		"func ",
		funcPrefix,
		"Start(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		", onRead func(*",
		respType,
		") bool, onDone func(error)) (uint64, error) {",
	)

	g.P("    protocol, h, err := ", lookupFuncName, "(ctx)")
	g.P("    if err != nil {")
	g.P("        return 0, err")
	g.P("    }")

	g.P(
		"    handle, childCtx, _ := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")),
		"(ctx, protocol)",
	)
	g.P(
		"    session := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")),
		"(handle)",
	)
	g.P("    if session == nil {")
	g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrInvalidStreamHandle")))
	g.P("    }")
	g.P("    session.SetCallbacks(func(resp any) bool { return onRead(resp.(*", respType, ")) }, onDone)")
	g.P()

	streamIface := service.GoName + "_" + method.GoName + "Server"

	if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) &&
		supportsProtocol(opts.Protocols, ProtocolOptionConnectRPC) {
		g.P("    if protocol == ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")), " {")
		g.P("        svc, ok := h.(", grpcServerIface, ")")
		g.P("        if !ok {")
		g.P("            return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
		g.P("        session.SetHandlerState(adaptorStream)")
		g.P("        go func() {")
		g.P("            err := svc.", method.GoName, "(adaptorStream)")
		g.P("            if cb := session.OnDone(); cb != nil {")
		g.P("                cb(err)")
		g.P("            }")
		g.P("            ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        }()")
		g.P("    } else if protocol == ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")), " {")
		g.P("        svc, ok := h.(", connectHandlerIface, ")")
		g.P("        if !ok {")
		g.P("            return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("        }")
		g.P("        conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
		g.P(
			"        connectStream := ",
			g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewBidiStream")),
			"[",
			reqType,
			", ",
			respType,
			"](conn)",
		)
		g.P("        session.SetHandlerState(connectStream)")
		g.P("        go func() {")
		g.P("            err := svc.", method.GoName, "(childCtx, connectStream)")
		g.P("            if cb := session.OnDone(); cb != nil {")
		g.P("                cb(err)")
		g.P("            }")
		g.P("            ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("        }()")
		g.P("    } else {")
		g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrUnknownProtocol")))
		g.P("    }")
	} else if supportsProtocol(opts.Protocols, ProtocolOptionGrpc) {
		g.P("    svc, ok := h.(", grpcServerIface, ")")
		g.P("    if !ok {")
		g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("    }")
		g.P("    adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
		g.P("    session.SetHandlerState(adaptorStream)")
		g.P("    go func() {")
		g.P("        err := svc.", method.GoName, "(adaptorStream)")
		g.P("        if cb := session.OnDone(); cb != nil {")
		g.P("            cb(err)")
		g.P("        }")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("    }()")
	} else {
		g.P("    svc, ok := h.(", connectHandlerIface, ")")
		g.P("    if !ok {")
		g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
		g.P("    }")
		g.P("    conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
		g.P("    connectStream := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewBidiStream")), "[", reqType, ", ", respType, "](conn)")
		g.P("    session.SetHandlerState(connectStream)")
		g.P("    go func() {")
		g.P("        err := svc.", method.GoName, "(childCtx, connectStream)")
		g.P("        if cb := session.OnDone(); cb != nil {")
		g.P("            cb(err)")
		g.P("        }")
		g.P("        ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
		g.P("    }()")
	}

	g.P()
	g.P("    _ = childCtx // Used in goroutine")
	g.P("    return uint64(handle), nil")
	g.P("}")
	g.P()

	// Send function
	g.P("// ", funcPrefix, "Send sends a request message to the stream.")
	g.P("func ", funcPrefix, "Send(streamHandle uint64, req *", reqType, ") error {")
	g.P(
		"    return ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("SendToStream")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle), req)",
	)
	g.P("}")
	g.P()

	// CloseSend function
	g.P("// ", funcPrefix, "CloseSend closes the send-side of the stream.")
	g.P("func ", funcPrefix, "CloseSend(streamHandle uint64) error {")
	g.P(
		"    return ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("CloseSendCh")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle))",
	)
	g.P("}")
	g.P()
}

func generateBidiStreamStartGrpc(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
}

func generateBidiStreamStartConnect(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
}

// generateStreamAdaptorType generates the adaptor struct that implements grpc's *_Server stream interface.
// This bridges the rpcruntime.streamSession with grpc's streaming expectations.
func generateStreamAdaptorType(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	framework string,
) {
	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()
	streamIface := service.GoName + "_" + method.GoName + "Server"
	adaptorName := unexport(streamIface) + "Adaptor"
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	sessionType := g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamSession"))

	g.P("// ", adaptorName, " adapts rpcruntime.StreamSession to ", streamIface, ".")
	g.P("type ", adaptorName, " struct {")
	g.P("    session ", sessionType)
	// For client-streaming, we need to store the response from SendAndClose.
	if isClientStreaming && !isServerStreaming {
		g.P("    lastResp *", respType)
	}
	g.P("}")
	g.P()

	// Implement grpc.ServerStream interface methods.
	g.P(
		"func (a *",
		adaptorName,
		") SetHeader(md ",
		g.QualifiedGoIdent(protogen.GoImportPath("google.golang.org/grpc/metadata").Ident("MD")),
		") error {",
	)
	g.P("    return nil // Not supported in CGO adaptor")
	g.P("}")
	g.P()

	g.P(
		"func (a *",
		adaptorName,
		") SendHeader(md ",
		g.QualifiedGoIdent(protogen.GoImportPath("google.golang.org/grpc/metadata").Ident("MD")),
		") error {",
	)
	g.P("    return nil // Not supported in CGO adaptor")
	g.P("}")
	g.P()

	g.P(
		"func (a *",
		adaptorName,
		") SetTrailer(md ",
		g.QualifiedGoIdent(protogen.GoImportPath("google.golang.org/grpc/metadata").Ident("MD")),
		") {",
	)
	g.P("    // Not supported in CGO adaptor")
	g.P("}")
	g.P()

	g.P("func (a *", adaptorName, ") Context() ", g.QualifiedGoIdent(contextPackage.Ident("Context")), " {")
	g.P("    return a.session.Context()")
	g.P("}")
	g.P()

	g.P("func (a *", adaptorName, ") SendMsg(m any) error {")
	g.P("    // Forward to onRead callback")
	g.P("    if cb := a.session.OnRead(); cb != nil {")
	g.P("        if !cb(m) {")
	g.P("            return ", g.QualifiedGoIdent(contextPackage.Ident("Canceled")))
	g.P("        }")
	g.P("    }")
	g.P("    return nil")
	g.P("}")
	g.P()

	g.P("func (a *", adaptorName, ") RecvMsg(m any) error {")
	g.P("    select {")
	g.P("    case msg, ok := <-a.session.SendCh():")
	g.P("        if !ok {")
	g.P("            return ", g.QualifiedGoIdent(protogen.GoImportPath("io").Ident("EOF")))
	g.P("        }")
	g.P("        // Copy message to m")
	g.P("        if src, ok := msg.(*", reqType, "); ok {")
	g.P("            if dst, ok := m.(*", reqType, "); ok {")
	g.P("                *dst = *src")
	g.P("            }")
	g.P("        }")
	g.P("        return nil")
	g.P("    case <-a.session.Context().Done():")
	g.P("        return a.session.Context().Err()")
	g.P("    }")
	g.P("}")
	g.P()

	// Generate streaming-specific methods based on streaming type.
	if isClientStreaming && !isServerStreaming {
		// Client-streaming: SendAndClose + Recv
		g.P("func (a *", adaptorName, ") SendAndClose(resp *", respType, ") error {")
		g.P("    // Store response for later retrieval")
		g.P("    a.lastResp = resp")
		g.P("    return nil")
		g.P("}")
		g.P()

		g.P("func (a *", adaptorName, ") Recv() (*", reqType, ", error) {")
		g.P("    msg := new(", reqType, ")")
		g.P("    if err := a.RecvMsg(msg); err != nil {")
		g.P("        return nil, err")
		g.P("    }")
		g.P("    return msg, nil")
		g.P("}")
		g.P()
	} else if !isClientStreaming && isServerStreaming {
		// Server-streaming: Send only
		g.P("func (a *", adaptorName, ") Send(resp *", respType, ") error {")
		g.P("    return a.SendMsg(resp)")
		g.P("}")
		g.P()
	} else {
		// Bidi-streaming: Send + Recv
		g.P("func (a *", adaptorName, ") Send(resp *", respType, ") error {")
		g.P("    return a.SendMsg(resp)")
		g.P("}")
		g.P()

		g.P("func (a *", adaptorName, ") Recv() (*", reqType, ", error) {")
		g.P("    msg := new(", reqType, ")")
		g.P("    if err := a.RecvMsg(msg); err != nil {")
		g.P("        return nil, err")
		g.P("    }")
		g.P("    return msg, nil")
		g.P("}")
		g.P()
	}

	// Add compile-time interface check.
	g.P("var _ ", streamIface, " = (*", adaptorName, ")(nil)")
	g.P()
}
