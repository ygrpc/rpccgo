// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.
//
// source: stream.proto
// protocols: connectrpc

package cgotest_connect

import (
	connect "connectrpc.com/connect"
	context "context"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
)

// StreamService adaptor constants.
const (
	StreamService_ServiceName                 = "cgotest.StreamService"
	StreamService_UnaryCall_FullMethod        = "/cgotest.StreamService/UnaryCall"
	StreamService_ClientStreamCall_FullMethod = "/cgotest.StreamService/ClientStreamCall"
	StreamService_ServerStreamCall_FullMethod = "/cgotest.StreamService/ServerStreamCall"
	StreamService_BidiStreamCall_FullMethod   = "/cgotest.StreamService/BidiStreamCall"
)

// StreamService_lookupHandler selects a protocol and looks up the registered handler.
//
// Selection rules:
// - If ctx explicitly carries a protocol, only that protocol is attempted (no fallback).
// - Otherwise, protocols are tried in the configured order: connectrpc
func StreamService_lookupHandler(ctx context.Context) (rpcruntime.Protocol, any, error) {
	protocol, hasProtocol := rpcruntime.ProtocolFromContext(ctx)
	if hasProtocol {
		if protocol != rpcruntime.ProtocolConnectRPC {
			return protocol, nil, rpcruntime.ErrUnknownProtocol
		}
		h, ok := rpcruntime.LookupConnectHandler(StreamService_ServiceName)
		if !ok {
			return protocol, nil, rpcruntime.ErrServiceNotRegistered
		}
		return protocol, h, nil
	}

	// Fallback: try protocols in configured order.
	if h, ok := rpcruntime.LookupConnectHandler(StreamService_ServiceName); ok {
		return rpcruntime.ProtocolConnectRPC, h, nil
	}
	return "", nil, rpcruntime.ErrServiceNotRegistered
}

// StreamService_UnaryCall calls cgotest.StreamService.UnaryCall via the registered handler.
func StreamService_UnaryCall(ctx context.Context, req *StreamRequest) (*StreamResponse, error) {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		return nil, err
	}
	switch protocol {
	case rpcruntime.ProtocolConnectRPC:
		svc, ok := h.(interface {
			UnaryCall(context.Context, *StreamRequest) (*StreamResponse, error)
		})
		if !ok {
			return nil, rpcruntime.ErrHandlerTypeMismatch
		}
		return svc.UnaryCall(ctx, req)
	default:
		return nil, rpcruntime.ErrUnknownProtocol
	}
}

// StreamService_ClientStreamCall client-streaming adaptor functions.
// These use a staged API: Start, Send, Finish.

// StreamService_ClientStreamCallStart initializes a client-streaming call and returns a stream handle.
func StreamService_ClientStreamCallStart(ctx context.Context) (uint64, error) {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		return 0, err
	}
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, protocol)
	session := rpcruntime.GetStreamSession(handle)
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}

	if protocol == rpcruntime.ProtocolConnectRPC {
		svc, ok := h.(interface {
			ClientStreamCall(context.Context, *connect.ClientStream[StreamRequest]) (*StreamResponse, error)
		})
		if !ok {
			return 0, rpcruntime.ErrHandlerTypeMismatch
		}
		conn := rpcruntime.NewConnectStreamConn(session)
		connectStream := rpcruntime.NewClientStream[StreamRequest](conn)
		go func() {
			resp, err := svc.ClientStreamCall(childCtx, connectStream)
			rpcruntime.CompleteClientStream(handle, resp, err)
		}()
	} else {
		return 0, rpcruntime.ErrUnknownProtocol
	}

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_ClientStreamCallSend sends a request message to the stream.
func StreamService_ClientStreamCallSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_ClientStreamCallFinish closes the send-side and returns the final response.
func StreamService_ClientStreamCallFinish(streamHandle uint64) (*StreamResponse, error) {
	resp, err := rpcruntime.FinishClientStream(rpcruntime.StreamHandle(streamHandle))
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, nil
	}
	return resp.(*StreamResponse), nil
}

// StreamService_ServerStreamCall calls cgotest.StreamService.ServerStreamCall via the registered handler.
//
// This is a server-streaming method. Results are delivered via callbacks:
// - onRead is called for each response message; return false to stop receiving.
// - onDone is called exactly once when the stream ends or fails.
func StreamService_ServerStreamCall(ctx context.Context, req *StreamRequest, onRead func(*StreamResponse) bool, onDone func(error)) error {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		onDone(err)
		return err
	}
	handle, _, _ := rpcruntime.AllocateStreamHandle(ctx, protocol)
	session := rpcruntime.GetStreamSession(handle)
	if session == nil {
		onDone(rpcruntime.ErrInvalidStreamHandle)
		return rpcruntime.ErrInvalidStreamHandle
	}
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)

	if protocol == rpcruntime.ProtocolConnectRPC {
		svc, ok := h.(interface {
			ServerStreamCall(context.Context, *StreamRequest, *connect.ServerStream[StreamResponse]) error
		})
		if !ok {
			rpcruntime.FinishStreamHandle(handle)
			onDone(rpcruntime.ErrHandlerTypeMismatch)
			return rpcruntime.ErrHandlerTypeMismatch
		}
		conn := rpcruntime.NewConnectStreamConn(session)
		connectStream := rpcruntime.NewServerStream[StreamResponse](conn)
		err := svc.ServerStreamCall(ctx, req, connectStream)
		rpcruntime.FinishStreamHandle(handle)
		onDone(err)
		return err
	} else {
		rpcruntime.FinishStreamHandle(handle)
		onDone(rpcruntime.ErrUnknownProtocol)
		return rpcruntime.ErrUnknownProtocol
	}
}

// StreamService_BidiStreamCall bidi-streaming adaptor functions.
// These use a combined staged + callback API: Start, Send, CloseSend + receive callbacks.

// StreamService_BidiStreamCallStart initializes a bidi-streaming call and returns a stream handle.
// Provide onRead and onDone callbacks to receive response messages.
func StreamService_BidiStreamCallStart(ctx context.Context, onRead func(*StreamResponse) bool, onDone func(error)) (uint64, error) {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		return 0, err
	}
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, protocol)
	session := rpcruntime.GetStreamSession(handle)
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)

	if protocol == rpcruntime.ProtocolConnectRPC {
		svc, ok := h.(interface {
			BidiStreamCall(context.Context, *connect.BidiStream[StreamRequest, StreamResponse]) error
		})
		if !ok {
			return 0, rpcruntime.ErrHandlerTypeMismatch
		}
		conn := rpcruntime.NewConnectStreamConn(session)
		connectStream := rpcruntime.NewBidiStream[StreamRequest, StreamResponse](conn)
		session.SetHandlerState(connectStream)
		go func() {
			err := svc.BidiStreamCall(childCtx, connectStream)
			if cb := session.OnDone(); cb != nil {
				cb(err)
			}
			rpcruntime.FinishStreamHandle(handle)
		}()
	} else {
		return 0, rpcruntime.ErrUnknownProtocol
	}

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_BidiStreamCallSend sends a request message to the stream.
func StreamService_BidiStreamCallSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_BidiStreamCallCloseSend closes the send-side of the stream.
func StreamService_BidiStreamCallCloseSend(streamHandle uint64) error {
	return rpcruntime.CloseSendCh(rpcruntime.StreamHandle(streamHandle))
}
