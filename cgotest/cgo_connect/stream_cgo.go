// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.
//
// source: stream.proto

package main

import (
	connect "github.com/ygrpc/rpccgo/cgotest/connect"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
	proto "google.golang.org/protobuf/proto"
	atomic "sync/atomic"
	unsafe "unsafe"
)

/*
#include "ygrpc_cgo_common.h"

typedef void (*OnReadNativeFunc_StreamService_ServerStreamCall)(
    void* result_ptr,
    int result_len,
    FreeFunc result_free,
    int32_t sequence,
    void* user_data
);
static inline void call_on_read_native_StreamService_ServerStreamCall(void* fn, void* user_data
    , void* result_ptr
    , int result_len
    , FreeFunc result_free
    , int32_t sequence
) {
    ((OnReadNativeFunc_StreamService_ServerStreamCall)fn)(
        result_ptr, result_len, result_free,
        sequence,
        user_data
    );
}

typedef void (*OnReadNativeFunc_StreamService_BidiStreamCall)(
    void* result_ptr,
    int result_len,
    FreeFunc result_free,
    int32_t sequence,
    void* user_data
);
static inline void call_on_read_native_StreamService_BidiStreamCall(void* fn, void* user_data
    , void* result_ptr
    , int result_len
    , FreeFunc result_free
    , int32_t sequence
) {
    ((OnReadNativeFunc_StreamService_BidiStreamCall)fn)(
        result_ptr, result_len, result_free,
        sequence,
        user_data
    );
}

*/
import "C"

//export Ygrpc_StreamService_UnaryCall
func Ygrpc_StreamService_UnaryCall(
	reqPtr unsafe.Pointer,
	reqLen C.int,
	respPtr *unsafe.Pointer,
	respLen *C.int,
	respFree *C.FreeFunc,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	respBytes, err := proto.Marshal(resp)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	buf := C.CBytes(respBytes)
	*respPtr = buf
	*respLen = C.int(len(respBytes))
	*respFree = (C.FreeFunc)(C.Ygrpc_Free)
	return 0
}

//export Ygrpc_StreamService_UnaryCall_TakeReq
func Ygrpc_StreamService_UnaryCall_TakeReq(
	reqPtr unsafe.Pointer,
	reqLen C.int,
	reqFree C.FreeFunc,
	respPtr *unsafe.Pointer,
	respLen *C.int,
	respFree *C.FreeFunc,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	if reqFree != nil {
		C.call_free_func(reqFree, reqPtr)
	}

	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	respBytes, err := proto.Marshal(resp)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	buf := C.CBytes(respBytes)
	*respPtr = buf
	*respLen = C.int(len(respBytes))
	*respFree = (C.FreeFunc)(C.Ygrpc_Free)
	return 0
}

//export Ygrpc_StreamService_UnaryCall_Native
func Ygrpc_StreamService_UnaryCall_Native(
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
	resp_result **C.char,
	resp_result_len *C.int,
	resp_result_free *C.FreeFunc,
	resp_sequence *C.int32_t,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	if len(resp.Result) > 0 {
		buf := C.CBytes([]byte(resp.Result))
		*resp_result = (*C.char)(buf)
		*resp_result_len = C.int(len(resp.Result))
		*resp_result_free = (C.FreeFunc)(C.Ygrpc_Free)
	} else {
		*resp_result = nil
		*resp_result_len = 0
		*resp_result_free = nil
	}
	*resp_sequence = C.int32_t(resp.Sequence)
	return 0
}

//export Ygrpc_StreamService_UnaryCall_Native_TakeReq
func Ygrpc_StreamService_UnaryCall_Native_TakeReq(
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
	resp_result **C.char,
	resp_result_len *C.int,
	resp_result_free *C.FreeFunc,
	resp_sequence *C.int32_t,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}

	if len(resp.Result) > 0 {
		buf := C.CBytes([]byte(resp.Result))
		*resp_result = (*C.char)(buf)
		*resp_result_len = C.int(len(resp.Result))
		*resp_result_free = (C.FreeFunc)(C.Ygrpc_Free)
	} else {
		*resp_result = nil
		*resp_result_len = 0
		*resp_result_free = nil
	}
	*resp_sequence = C.int32_t(resp.Sequence)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallStart
func Ygrpc_StreamService_ClientStreamCallStart(outHandle *C.uint64_t) C.int {
	ctx := rpcruntime.BackgroundContext()
	handle, err := connect.StreamService_ClientStreamCallStart(ctx)
	if err != nil {
		*outHandle = 0
		return C.int(rpcruntime.StoreError(err))
	}
	*outHandle = C.uint64_t(handle)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend
func Ygrpc_StreamService_ClientStreamCallSend(
	streamHandle C.uint64_t,
	reqPtr unsafe.Pointer,
	reqLen C.int,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend_TakeReq
func Ygrpc_StreamService_ClientStreamCallSend_TakeReq(
	streamHandle C.uint64_t,
	reqPtr unsafe.Pointer,
	reqLen C.int,
	reqFree C.FreeFunc,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	if reqFree != nil {
		C.call_free_func(reqFree, reqPtr)
	}
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallFinish
func Ygrpc_StreamService_ClientStreamCallFinish(
	streamHandle C.uint64_t,
	respPtr *unsafe.Pointer,
	respLen *C.int,
	respFree *C.FreeFunc,
) C.int {
	resp, err := connect.StreamService_ClientStreamCallFinish(uint64(streamHandle))
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	if resp == nil {
		*respPtr = nil
		*respLen = 0
		*respFree = nil
		return 0
	}
	respBytes, err := proto.Marshal(resp)
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	buf := C.CBytes(respBytes)
	*respPtr = buf
	*respLen = C.int(len(respBytes))
	*respFree = (C.FreeFunc)(C.Ygrpc_Free)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallStart_Native
func Ygrpc_StreamService_ClientStreamCallStart_Native(outHandle *C.uint64_t) C.int {
	ctx := rpcruntime.BackgroundContext()
	handle, err := connect.StreamService_ClientStreamCallStart(ctx)
	if err != nil {
		*outHandle = 0
		return C.int(rpcruntime.StoreError(err))
	}
	*outHandle = C.uint64_t(handle)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend_Native
func Ygrpc_StreamService_ClientStreamCallSend_Native(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend_Native_TakeReq
func Ygrpc_StreamService_ClientStreamCallSend_Native_TakeReq(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallFinish_Native
func Ygrpc_StreamService_ClientStreamCallFinish_Native(
	streamHandle C.uint64_t,
	resp_result **C.char,
	resp_result_len *C.int,
	resp_result_free *C.FreeFunc,
	resp_sequence *C.int32_t,
) C.int {
	resp, err := connect.StreamService_ClientStreamCallFinish(uint64(streamHandle))
	if err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	if resp == nil {
		resp = &connect.StreamResponse{}
	}
	if len(resp.Result) > 0 {
		buf := C.CBytes([]byte(resp.Result))
		*resp_result = (*C.char)(buf)
		*resp_result_len = C.int(len(resp.Result))
		*resp_result_free = (C.FreeFunc)(C.Ygrpc_Free)
	} else {
		*resp_result = nil
		*resp_result_len = 0
		*resp_result_free = nil
	}
	*resp_sequence = C.int32_t(resp.Sequence)
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall
func Ygrpc_StreamService_ServerStreamCall(
	reqPtr unsafe.Pointer,
	reqLen C.int,
	onReadBytes unsafe.Pointer,
	onDone unsafe.Pointer,
	userData unsafe.Pointer,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Int64
	onRead := func(resp *connect.StreamResponse) bool {
		respBytes, err := proto.Marshal(resp)
		if err != nil {
			return false
		}
		respCopy := C.CBytes(respBytes)
		C.call_on_read_bytes(onReadBytes, respCopy, C.int(len(respBytes)), (C.FreeFunc)(C.Ygrpc_Free), userData)
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, C.int(doneErrId.Load()), userData)
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return C.int(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall_TakeReq
func Ygrpc_StreamService_ServerStreamCall_TakeReq(
	reqPtr unsafe.Pointer,
	reqLen C.int,
	reqFree C.FreeFunc,
	onReadBytes unsafe.Pointer,
	onDone unsafe.Pointer,
	userData unsafe.Pointer,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	if reqFree != nil {
		C.call_free_func(reqFree, reqPtr)
	}
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Int64
	onRead := func(resp *connect.StreamResponse) bool {
		respBytes, err := proto.Marshal(resp)
		if err != nil {
			return false
		}
		respCopy := C.CBytes(respBytes)
		C.call_on_read_bytes(onReadBytes, respCopy, C.int(len(respBytes)), (C.FreeFunc)(C.Ygrpc_Free), userData)
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, C.int(doneErrId.Load()), userData)
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return C.int(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall_Native
func Ygrpc_StreamService_ServerStreamCall_Native(
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
	onReadNative unsafe.Pointer,
	onDone unsafe.Pointer,
	userData unsafe.Pointer,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Int64
	onRead := func(resp *connect.StreamResponse) bool {

		var result_ptr unsafe.Pointer
		var result_len C.int
		var result_free C.FreeFunc
		if len(resp.Result) > 0 {
			result_ptr = C.CBytes([]byte(resp.Result))
			result_len = C.int(len(resp.Result))
			result_free = (C.FreeFunc)(C.Ygrpc_Free)
		}
		sequence := C.int32_t(resp.Sequence)
		C.call_on_read_native_StreamService_ServerStreamCall(onReadNative, userData,
			result_ptr, result_len, result_free,
			sequence,
		)
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, C.int(doneErrId.Load()), userData)
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return C.int(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall_Native_TakeReq
func Ygrpc_StreamService_ServerStreamCall_Native_TakeReq(
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
	onReadNative unsafe.Pointer,
	onDone unsafe.Pointer,
	userData unsafe.Pointer,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Int64
	onRead := func(resp *connect.StreamResponse) bool {
		var result_ptr unsafe.Pointer
		var result_len C.int
		var result_free C.FreeFunc
		if len(resp.Result) > 0 {
			result_ptr = C.CBytes([]byte(resp.Result))
			result_len = C.int(len(resp.Result))
			result_free = (C.FreeFunc)(C.Ygrpc_Free)
		}
		sequence := C.int32_t(resp.Sequence)
		C.call_on_read_native_StreamService_ServerStreamCall(onReadNative, userData,
			result_ptr, result_len, result_free,
			sequence,
		)
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, C.int(doneErrId.Load()), userData)
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return C.int(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallStart
func Ygrpc_StreamService_BidiStreamCallStart(
	onReadBytes unsafe.Pointer,
	onDone unsafe.Pointer,
	userData unsafe.Pointer,
	outHandle *C.uint64_t,
) C.int {
	ctx := rpcruntime.BackgroundContext()
	onRead := func(resp *connect.StreamResponse) bool {
		respBytes, err := proto.Marshal(resp)
		if err != nil {
			return false
		}
		respCopy := C.CBytes(respBytes)
		C.call_on_read_bytes(onReadBytes, respCopy, C.int(len(respBytes)), (C.FreeFunc)(C.Ygrpc_Free), userData)
		return true
	}
	onDoneFunc := func(err error) {
		errId := int64(0)
		if err != nil {
			errId = rpcruntime.StoreError(err)
		}
		C.call_on_done(onDone, C.int(errId), userData)
	}
	handle, err := connect.StreamService_BidiStreamCallStart(ctx, onRead, onDoneFunc)
	if err != nil {
		*outHandle = 0
		return C.int(rpcruntime.StoreError(err))
	}
	*outHandle = C.uint64_t(handle)
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend
func Ygrpc_StreamService_BidiStreamCallSend(
	streamHandle C.uint64_t,
	reqPtr unsafe.Pointer,
	reqLen C.int,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend_TakeReq
func Ygrpc_StreamService_BidiStreamCallSend_TakeReq(
	streamHandle C.uint64_t,
	reqPtr unsafe.Pointer,
	reqLen C.int,
	reqFree C.FreeFunc,
) C.int {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	if reqFree != nil {
		C.call_free_func(reqFree, reqPtr)
	}
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallCloseSend
func Ygrpc_StreamService_BidiStreamCallCloseSend(streamHandle C.uint64_t) C.int {
	if err := connect.StreamService_BidiStreamCallCloseSend(uint64(streamHandle)); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallStart_Native
func Ygrpc_StreamService_BidiStreamCallStart_Native(
	onReadNative unsafe.Pointer,
	onDone unsafe.Pointer,
	userData unsafe.Pointer,
	outHandle *C.uint64_t,
) C.int {
	ctx := rpcruntime.BackgroundContext()
	onRead := func(resp *connect.StreamResponse) bool {
		var result_ptr unsafe.Pointer
		var result_len C.int
		var result_free C.FreeFunc
		if len(resp.Result) > 0 {
			result_ptr = C.CBytes([]byte(resp.Result))
			result_len = C.int(len(resp.Result))
			result_free = (C.FreeFunc)(C.Ygrpc_Free)
		}
		sequence := C.int32_t(resp.Sequence)
		C.call_on_read_native_StreamService_BidiStreamCall(onReadNative, userData,
			result_ptr, result_len, result_free,
			sequence,
		)
		return true
	}
	onDoneFunc := func(err error) {
		errId := int64(0)
		if err != nil {
			errId = rpcruntime.StoreError(err)
		}
		C.call_on_done(onDone, C.int(errId), userData)
	}
	handle, err := connect.StreamService_BidiStreamCallStart(ctx, onRead, onDoneFunc)
	if err != nil {
		*outHandle = 0
		return C.int(rpcruntime.StoreError(err))
	}
	*outHandle = C.uint64_t(handle)
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend_Native
func Ygrpc_StreamService_BidiStreamCallSend_Native(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend_Native_TakeReq
func Ygrpc_StreamService_BidiStreamCallSend_Native_TakeReq(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
) C.int {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallCloseSend_Native
func Ygrpc_StreamService_BidiStreamCallCloseSend_Native(streamHandle C.uint64_t) C.int {
	if err := connect.StreamService_BidiStreamCallCloseSend(uint64(streamHandle)); err != nil {
		return C.int(rpcruntime.StoreError(err))
	}
	return 0
}
