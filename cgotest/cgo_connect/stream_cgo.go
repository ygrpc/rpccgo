// Code generated by protoc-gen-rpc-cgo. DO NOT EDIT.
//
// source: stream.proto

//go:build cgo

package main

import (
	connect "github.com/ygrpc/rpccgo/cgotest/connect"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
	proto "google.golang.org/protobuf/proto"
	atomic "sync/atomic"
	unsafe "unsafe"
)

/*
#include "ygrpc_cgo_common.h"

typedef void (*OnReadNativeFunc_StreamService_ServerStreamCall)(
    uint64_t call_id
    , void* result_ptr
    , int result_len
    , FreeFunc result_free
    , int32_t sequence
);
static inline void call_on_read_native_StreamService_ServerStreamCall(void* fn, uint64_t call_id
    , void* result_ptr
    , int result_len
    , FreeFunc result_free
    , int32_t sequence
) {
    ((OnReadNativeFunc_StreamService_ServerStreamCall)fn)(
        call_id
        , result_ptr, result_len, result_free
        , sequence
    );
}

typedef void (*OnReadNativeFunc_StreamService_BidiStreamCall)(
    uint64_t call_id
    , void* result_ptr
    , int result_len
    , FreeFunc result_free
    , int32_t sequence
);
static inline void call_on_read_native_StreamService_BidiStreamCall(void* fn, uint64_t call_id
    , void* result_ptr
    , int result_len
    , FreeFunc result_free
    , int32_t sequence
) {
    ((OnReadNativeFunc_StreamService_BidiStreamCall)fn)(
        call_id
        , result_ptr, result_len, result_free
        , sequence
    );
}

*/
import "C"

//export Ygrpc_StreamService_UnaryCall
func Ygrpc_StreamService_UnaryCall(
	reqPtr unsafe.Pointer,
	reqLen int,
	respPtr *unsafe.Pointer,
	respLen *int,
	respFree *unsafe.Pointer,
) uint64 {
	reqBytes := unsafe.Slice((*byte)(reqPtr), reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return uint64(rpcruntime.StoreError(err))
	}

	respBytes, err := proto.Marshal(resp)
	if err != nil {
		return uint64(rpcruntime.StoreError(err))
	}

	buf := C.CBytes(respBytes)
	*respPtr = buf
	*respLen = len(respBytes)
	*respFree = (unsafe.Pointer)(C.Ygrpc_Free)
	return 0
}

//export Ygrpc_StreamService_UnaryCall_TakeReq
func Ygrpc_StreamService_UnaryCall_TakeReq(
	reqPtr unsafe.Pointer,
	reqLen int,
	reqFree unsafe.Pointer,
	respPtr *unsafe.Pointer,
	respLen *int,
	respFree *unsafe.Pointer,
) uint64 {
	reqBytes := unsafe.Slice((*byte)(reqPtr), reqLen)
	if reqFree != nil {
		C.call_free_func((C.FreeFunc)(reqFree), reqPtr)
	}

	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return uint64(rpcruntime.StoreError(err))
	}

	respBytes, err := proto.Marshal(resp)
	if err != nil {
		return uint64(rpcruntime.StoreError(err))
	}

	buf := C.CBytes(respBytes)
	*respPtr = buf
	*respLen = len(respBytes)
	*respFree = (unsafe.Pointer)(C.Ygrpc_Free)
	return 0
}

//export Ygrpc_StreamService_UnaryCall_Native
func Ygrpc_StreamService_UnaryCall_Native(
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
	resp_result **C.char,
	resp_result_len *C.int,
	resp_result_free *C.FreeFunc,
	resp_sequence *C.int32_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}

	if len(resp.Result) > 0 {
		buf := C.CBytes([]byte(resp.Result))
		*resp_result = (*C.char)(buf)
		*resp_result_len = C.int(len(resp.Result))
		*resp_result_free = (C.FreeFunc)(C.Ygrpc_Free)
	} else {
		*resp_result = nil
		*resp_result_len = 0
		*resp_result_free = nil
	}
	*resp_sequence = C.int32_t(resp.Sequence)
	return 0
}

//export Ygrpc_StreamService_UnaryCall_Native_TakeReq
func Ygrpc_StreamService_UnaryCall_Native_TakeReq(
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
	resp_result **C.char,
	resp_result_len *C.int,
	resp_result_free *C.FreeFunc,
	resp_sequence *C.int32_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)

	ctx := rpcruntime.BackgroundContext()
	resp, err := connect.StreamService_UnaryCall(ctx, req)
	if err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}

	if len(resp.Result) > 0 {
		buf := C.CBytes([]byte(resp.Result))
		*resp_result = (*C.char)(buf)
		*resp_result_len = C.int(len(resp.Result))
		*resp_result_free = (C.FreeFunc)(C.Ygrpc_Free)
	} else {
		*resp_result = nil
		*resp_result_len = 0
		*resp_result_free = nil
	}
	*resp_sequence = C.int32_t(resp.Sequence)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallStart
func Ygrpc_StreamService_ClientStreamCallStart(outHandle *uint64) uint64 {
	ctx := rpcruntime.BackgroundContext()
	handle, err := connect.StreamService_ClientStreamCallStart(ctx)
	if err != nil {
		*outHandle = 0
		return uint64(rpcruntime.StoreError(err))
	}
	*outHandle = uint64(handle)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend
func Ygrpc_StreamService_ClientStreamCallSend(
	streamHandle C.uint64_t,
	reqPtr unsafe.Pointer,
	reqLen C.int,
) C.uint64_t {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend_TakeReq
func Ygrpc_StreamService_ClientStreamCallSend_TakeReq(
	streamHandle C.uint64_t,
	reqPtr unsafe.Pointer,
	reqLen C.int,
	reqFree C.FreeFunc,
) C.uint64_t {
	reqBytes := C.GoBytes(reqPtr, reqLen)
	if reqFree != nil {
		C.call_free_func(reqFree, reqPtr)
	}
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallFinish
func Ygrpc_StreamService_ClientStreamCallFinish(
	streamHandle uint64,
	respPtr *unsafe.Pointer,
	respLen *int,
	respFree *unsafe.Pointer,
) uint64 {
	resp, err := connect.StreamService_ClientStreamCallFinish(uint64(streamHandle))
	if err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	if resp == nil {
		*respPtr = nil
		*respLen = 0
		*respFree = nil
		return 0
	}
	respBytes, err := proto.Marshal(resp)
	if err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	buf := C.CBytes(respBytes)
	*respPtr = buf
	*respLen = len(respBytes)
	*respFree = (unsafe.Pointer)(C.Ygrpc_Free)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallStart_Native
func Ygrpc_StreamService_ClientStreamCallStart_Native(outHandle *uint64) uint64 {
	ctx := rpcruntime.BackgroundContext()
	handle, err := connect.StreamService_ClientStreamCallStart(ctx)
	if err != nil {
		*outHandle = 0
		return uint64(rpcruntime.StoreError(err))
	}
	*outHandle = uint64(handle)
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend_Native
func Ygrpc_StreamService_ClientStreamCallSend_Native(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallSend_Native_TakeReq
func Ygrpc_StreamService_ClientStreamCallSend_Native_TakeReq(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_ClientStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_ClientStreamCallFinish_Native
func Ygrpc_StreamService_ClientStreamCallFinish_Native(
	streamHandle C.uint64_t,
	resp_result **C.char,
	resp_result_len *C.int,
	resp_result_free *C.FreeFunc,
	resp_sequence *C.int32_t,
) C.uint64_t {
	resp, err := connect.StreamService_ClientStreamCallFinish(uint64(streamHandle))
	if err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	if resp == nil {
		resp = &connect.StreamResponse{}
	}
	if len(resp.Result) > 0 {
		buf := C.CBytes([]byte(resp.Result))
		*resp_result = (*C.char)(buf)
		*resp_result_len = C.int(len(resp.Result))
		*resp_result_free = (C.FreeFunc)(C.Ygrpc_Free)
	} else {
		*resp_result = nil
		*resp_result_len = 0
		*resp_result_free = nil
	}
	*resp_sequence = C.int32_t(resp.Sequence)
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall
func Ygrpc_StreamService_ServerStreamCall(
	reqPtr unsafe.Pointer,
	reqLen int,
	onReadBytes unsafe.Pointer,
	onDone unsafe.Pointer,
	callID uint64,
) uint64 {
	reqBytes := unsafe.Slice((*byte)(reqPtr), reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Uint64
	onRead := func(resp *connect.StreamResponse) bool {
		respBytes, err := proto.Marshal(resp)
		if err != nil {
			return false
		}
		respCopy := C.CBytes(respBytes)
		C.call_on_read_bytes(onReadBytes, C.uint64_t(callID), respCopy, C.int(len(respBytes)), (C.FreeFunc)(C.Ygrpc_Free))
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, C.uint64_t(callID), C.uint64_t(doneErrId.Load()))
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return uint64(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall_TakeReq
func Ygrpc_StreamService_ServerStreamCall_TakeReq(
	reqPtr unsafe.Pointer,
	reqLen int,
	reqFree unsafe.Pointer,
	onReadBytes unsafe.Pointer,
	onDone unsafe.Pointer,
	callID uint64,
) uint64 {
	reqBytes := unsafe.Slice((*byte)(reqPtr), reqLen)
	if reqFree != nil {
		C.call_free_func((C.FreeFunc)(reqFree), reqPtr)
	}
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Uint64
	onRead := func(resp *connect.StreamResponse) bool {
		respBytes, err := proto.Marshal(resp)
		if err != nil {
			return false
		}
		respCopy := C.CBytes(respBytes)
		C.call_on_read_bytes(onReadBytes, C.uint64_t(callID), respCopy, C.int(len(respBytes)), (C.FreeFunc)(C.Ygrpc_Free))
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, C.uint64_t(callID), C.uint64_t(doneErrId.Load()))
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return uint64(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall_Native
func Ygrpc_StreamService_ServerStreamCall_Native(
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
	onReadNative unsafe.Pointer,
	onDone unsafe.Pointer,
	callID C.uint64_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Uint64
	onRead := func(resp *connect.StreamResponse) bool {

		var result_ptr unsafe.Pointer
		var result_len C.int
		var result_free C.FreeFunc
		if len(resp.Result) > 0 {
			result_ptr = C.CBytes([]byte(resp.Result))
			result_len = C.int(len(resp.Result))
			result_free = (C.FreeFunc)(C.Ygrpc_Free)
		}
		sequence := C.int32_t(resp.Sequence)
		C.call_on_read_native_StreamService_ServerStreamCall(onReadNative, callID,
			result_ptr, result_len, result_free,
			sequence,
		)
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, callID, C.uint64_t(doneErrId.Load()))
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return C.uint64_t(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_ServerStreamCall_Native_TakeReq
func Ygrpc_StreamService_ServerStreamCall_Native_TakeReq(
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
	onReadNative unsafe.Pointer,
	onDone unsafe.Pointer,
	callID C.uint64_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)
	ctx := rpcruntime.BackgroundContext()
	var doneErrId atomic.Uint64
	onRead := func(resp *connect.StreamResponse) bool {
		var result_ptr unsafe.Pointer
		var result_len C.int
		var result_free C.FreeFunc
		if len(resp.Result) > 0 {
			result_ptr = C.CBytes([]byte(resp.Result))
			result_len = C.int(len(resp.Result))
			result_free = (C.FreeFunc)(C.Ygrpc_Free)
		}
		sequence := C.int32_t(resp.Sequence)
		C.call_on_read_native_StreamService_ServerStreamCall(onReadNative, callID,
			result_ptr, result_len, result_free,
			sequence,
		)
		return true
	}
	onDoneFunc := func(err error) {
		if err != nil {
			doneErrId.Store(rpcruntime.StoreError(err))
		} else {
			doneErrId.Store(0)
		}
		C.call_on_done(onDone, callID, C.uint64_t(doneErrId.Load()))
	}
	err := connect.StreamService_ServerStreamCall(ctx, req, onRead, onDoneFunc)
	if err != nil {
		if doneErrId.Load() == 0 {
			doneErrId.Store(rpcruntime.StoreError(err))
		}
		return C.uint64_t(doneErrId.Load())
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallStart
func Ygrpc_StreamService_BidiStreamCallStart(
	onReadBytes unsafe.Pointer,
	onDone unsafe.Pointer,
	outHandle *uint64,
) uint64 {
	ctx := rpcruntime.BackgroundContext()
	handleReady := make(chan struct{})
	var streamHandle uint64
	onRead := func(resp *connect.StreamResponse) bool {
		<-handleReady
		respBytes, err := proto.Marshal(resp)
		if err != nil {
			return false
		}
		respCopy := C.CBytes(respBytes)
		C.call_on_read_bytes(onReadBytes, C.uint64_t(streamHandle), respCopy, C.int(len(respBytes)), (C.FreeFunc)(C.Ygrpc_Free))
		return true
	}
	onDoneFunc := func(err error) {
		<-handleReady
		errId := uint64(0)
		if err != nil {
			errId = rpcruntime.StoreError(err)
		}
		C.call_on_done(onDone, C.uint64_t(streamHandle), C.uint64_t(errId))
	}
	handle, err := connect.StreamService_BidiStreamCallStart(ctx, onRead, onDoneFunc)
	if err != nil {
		*outHandle = 0
		return uint64(rpcruntime.StoreError(err))
	}
	streamHandle = handle
	close(handleReady)
	*outHandle = uint64(handle)
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend
func Ygrpc_StreamService_BidiStreamCallSend(
	streamHandle uint64,
	reqPtr unsafe.Pointer,
	reqLen int,
) uint64 {
	reqBytes := unsafe.Slice((*byte)(reqPtr), reqLen)
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend_TakeReq
func Ygrpc_StreamService_BidiStreamCallSend_TakeReq(
	streamHandle uint64,
	reqPtr unsafe.Pointer,
	reqLen int,
	reqFree unsafe.Pointer,
) uint64 {
	reqBytes := unsafe.Slice((*byte)(reqPtr), reqLen)
	if reqFree != nil {
		C.call_free_func((C.FreeFunc)(reqFree), reqPtr)
	}
	req := &connect.StreamRequest{}
	if err := proto.Unmarshal(reqBytes, req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallCloseSend
func Ygrpc_StreamService_BidiStreamCallCloseSend(streamHandle uint64) uint64 {
	if err := connect.StreamService_BidiStreamCallCloseSend(uint64(streamHandle)); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallStart_Native
func Ygrpc_StreamService_BidiStreamCallStart_Native(
	onReadNative unsafe.Pointer,
	onDone unsafe.Pointer,
	outHandle *C.uint64_t,
) C.uint64_t {
	ctx := rpcruntime.BackgroundContext()
	handleReady := make(chan struct{})
	var streamHandle uint64
	onRead := func(resp *connect.StreamResponse) bool {
		<-handleReady
		var result_ptr unsafe.Pointer
		var result_len C.int
		var result_free C.FreeFunc
		if len(resp.Result) > 0 {
			result_ptr = C.CBytes([]byte(resp.Result))
			result_len = C.int(len(resp.Result))
			result_free = (C.FreeFunc)(C.Ygrpc_Free)
		}
		sequence := C.int32_t(resp.Sequence)
		C.call_on_read_native_StreamService_BidiStreamCall(onReadNative, C.uint64_t(streamHandle),
			result_ptr, result_len, result_free,
			sequence,
		)
		return true
	}
	onDoneFunc := func(err error) {
		<-handleReady
		errId := uint64(0)
		if err != nil {
			errId = rpcruntime.StoreError(err)
		}
		C.call_on_done(onDone, C.uint64_t(streamHandle), C.uint64_t(errId))
	}
	handle, err := connect.StreamService_BidiStreamCallStart(ctx, onRead, onDoneFunc)
	if err != nil {
		*outHandle = 0
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	streamHandle = handle
	close(handleReady)
	*outHandle = C.uint64_t(handle)
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend_Native
func Ygrpc_StreamService_BidiStreamCallSend_Native(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_sequence C.int32_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallSend_Native_TakeReq
func Ygrpc_StreamService_BidiStreamCallSend_Native_TakeReq(
	streamHandle C.uint64_t,
	req_data *C.char,
	req_data_len C.int,
	req_data_free C.FreeFunc,
	req_sequence C.int32_t,
) C.uint64_t {
	req := &connect.StreamRequest{}
	req.Data = C.GoStringN(req_data, req_data_len)
	if req_data_free != nil {
		C.call_free_func(req_data_free, unsafe.Pointer(req_data))
	}
	req.Sequence = int32(req_sequence)
	if err := connect.StreamService_BidiStreamCallSend(uint64(streamHandle), req); err != nil {
		return C.uint64_t(rpcruntime.StoreError(err))
	}
	return 0
}

//export Ygrpc_StreamService_BidiStreamCallCloseSend_Native
func Ygrpc_StreamService_BidiStreamCallCloseSend_Native(streamHandle uint64) uint64 {
	if err := connect.StreamService_BidiStreamCallCloseSend(uint64(streamHandle)); err != nil {
		return uint64(rpcruntime.StoreError(err))
	}
	return 0
}
