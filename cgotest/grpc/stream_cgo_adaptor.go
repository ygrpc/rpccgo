// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.
//
// source: stream.proto
// protocols: grpc

package cgotest_grpc

import (
	context "context"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
	metadata "google.golang.org/grpc/metadata"
	io "io"
)

// StreamService adaptor constants.
const (
	StreamService_ServiceName                 = "cgotest.StreamService"
	StreamService_UnaryCall_FullMethod        = "/cgotest.StreamService/UnaryCall"
	StreamService_ClientStreamCall_FullMethod = "/cgotest.StreamService/ClientStreamCall"
	StreamService_ServerStreamCall_FullMethod = "/cgotest.StreamService/ServerStreamCall"
	StreamService_BidiStreamCall_FullMethod   = "/cgotest.StreamService/BidiStreamCall"
)

// StreamService_lookupHandler selects a protocol and looks up the registered handler.
//
// Selection rules:
// - Supported protocol: grpc
// - If ctx explicitly carries a protocol, it must match the supported protocol.
// - Otherwise, the supported protocol is used.
func StreamService_lookupHandler(ctx context.Context) (rpcruntime.Protocol, any, error) {
	protocol, hasProtocol := rpcruntime.ProtocolFromContext(ctx)
	if hasProtocol && protocol != rpcruntime.ProtocolGrpc {
		return protocol, nil, rpcruntime.ErrUnknownProtocol
	}
	h, ok := rpcruntime.LookupGrpcHandler(StreamService_ServiceName)
	if !ok {
		return "", nil, rpcruntime.ErrServiceNotRegistered
	}
	return rpcruntime.ProtocolGrpc, h, nil
}

// streamService_ClientStreamCallServerAdaptor adapts rpcruntime.StreamSession to StreamService_ClientStreamCallServer.
type streamService_ClientStreamCallServerAdaptor struct {
	session  rpcruntime.StreamSession
	lastResp *StreamResponse
}

func (a *streamService_ClientStreamCallServerAdaptor) SetHeader(md metadata.MD) error {
	return nil // Not supported in CGO adaptor
}

func (a *streamService_ClientStreamCallServerAdaptor) SendHeader(md metadata.MD) error {
	return nil // Not supported in CGO adaptor
}

func (a *streamService_ClientStreamCallServerAdaptor) SetTrailer(md metadata.MD) {
	// Not supported in CGO adaptor
}

func (a *streamService_ClientStreamCallServerAdaptor) Context() context.Context {
	return a.session.Context()
}

func (a *streamService_ClientStreamCallServerAdaptor) SendMsg(m any) error {
	// Forward to onRead callback
	if cb := a.session.OnRead(); cb != nil {
		if !cb(m) {
			return context.Canceled
		}
	}
	return nil
}

func (a *streamService_ClientStreamCallServerAdaptor) RecvMsg(m any) error {
	select {
	case msg, ok := <-a.session.SendCh():
		if !ok {
			return io.EOF
		}
		// Copy message to m
		if src, ok := msg.(*StreamRequest); ok {
			if dst, ok := m.(*StreamRequest); ok {
				*dst = *src
			}
		}
		return nil
	case <-a.session.Context().Done():
		return a.session.Context().Err()
	}
}

func (a *streamService_ClientStreamCallServerAdaptor) SendAndClose(resp *StreamResponse) error {
	// Store response for later retrieval
	a.lastResp = resp
	return nil
}

func (a *streamService_ClientStreamCallServerAdaptor) Recv() (*StreamRequest, error) {
	msg := new(StreamRequest)
	if err := a.RecvMsg(msg); err != nil {
		return nil, err
	}
	return msg, nil
}

var _ StreamService_ClientStreamCallServer = (*streamService_ClientStreamCallServerAdaptor)(nil)

// streamService_ServerStreamCallServerAdaptor adapts rpcruntime.StreamSession to StreamService_ServerStreamCallServer.
type streamService_ServerStreamCallServerAdaptor struct {
	session rpcruntime.StreamSession
}

func (a *streamService_ServerStreamCallServerAdaptor) SetHeader(md metadata.MD) error {
	return nil // Not supported in CGO adaptor
}

func (a *streamService_ServerStreamCallServerAdaptor) SendHeader(md metadata.MD) error {
	return nil // Not supported in CGO adaptor
}

func (a *streamService_ServerStreamCallServerAdaptor) SetTrailer(md metadata.MD) {
	// Not supported in CGO adaptor
}

func (a *streamService_ServerStreamCallServerAdaptor) Context() context.Context {
	return a.session.Context()
}

func (a *streamService_ServerStreamCallServerAdaptor) SendMsg(m any) error {
	// Forward to onRead callback
	if cb := a.session.OnRead(); cb != nil {
		if !cb(m) {
			return context.Canceled
		}
	}
	return nil
}

func (a *streamService_ServerStreamCallServerAdaptor) RecvMsg(m any) error {
	select {
	case msg, ok := <-a.session.SendCh():
		if !ok {
			return io.EOF
		}
		// Copy message to m
		if src, ok := msg.(*StreamRequest); ok {
			if dst, ok := m.(*StreamRequest); ok {
				*dst = *src
			}
		}
		return nil
	case <-a.session.Context().Done():
		return a.session.Context().Err()
	}
}

func (a *streamService_ServerStreamCallServerAdaptor) Send(resp *StreamResponse) error {
	return a.SendMsg(resp)
}

var _ StreamService_ServerStreamCallServer = (*streamService_ServerStreamCallServerAdaptor)(nil)

// streamService_BidiStreamCallServerAdaptor adapts rpcruntime.StreamSession to StreamService_BidiStreamCallServer.
type streamService_BidiStreamCallServerAdaptor struct {
	session rpcruntime.StreamSession
}

func (a *streamService_BidiStreamCallServerAdaptor) SetHeader(md metadata.MD) error {
	return nil // Not supported in CGO adaptor
}

func (a *streamService_BidiStreamCallServerAdaptor) SendHeader(md metadata.MD) error {
	return nil // Not supported in CGO adaptor
}

func (a *streamService_BidiStreamCallServerAdaptor) SetTrailer(md metadata.MD) {
	// Not supported in CGO adaptor
}

func (a *streamService_BidiStreamCallServerAdaptor) Context() context.Context {
	return a.session.Context()
}

func (a *streamService_BidiStreamCallServerAdaptor) SendMsg(m any) error {
	// Forward to onRead callback
	if cb := a.session.OnRead(); cb != nil {
		if !cb(m) {
			return context.Canceled
		}
	}
	return nil
}

func (a *streamService_BidiStreamCallServerAdaptor) RecvMsg(m any) error {
	select {
	case msg, ok := <-a.session.SendCh():
		if !ok {
			return io.EOF
		}
		// Copy message to m
		if src, ok := msg.(*StreamRequest); ok {
			if dst, ok := m.(*StreamRequest); ok {
				*dst = *src
			}
		}
		return nil
	case <-a.session.Context().Done():
		return a.session.Context().Err()
	}
}

func (a *streamService_BidiStreamCallServerAdaptor) Send(resp *StreamResponse) error {
	return a.SendMsg(resp)
}

func (a *streamService_BidiStreamCallServerAdaptor) Recv() (*StreamRequest, error) {
	msg := new(StreamRequest)
	if err := a.RecvMsg(msg); err != nil {
		return nil, err
	}
	return msg, nil
}

var _ StreamService_BidiStreamCallServer = (*streamService_BidiStreamCallServerAdaptor)(nil)

// StreamService_UnaryCall calls cgotest.StreamService.UnaryCall via the registered handler.
func StreamService_UnaryCall(ctx context.Context, req *StreamRequest) (*StreamResponse, error) {
	_, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		return nil, err
	}
	svc, ok := h.(StreamServiceServer)
	if !ok {
		return nil, rpcruntime.ErrHandlerTypeMismatch
	}
	return svc.UnaryCall(ctx, req)
}

// StreamService_ClientStreamCall client-streaming adaptor functions.
// These use a staged API: Start, Send, Finish.

// StreamService_ClientStreamCallStart initializes a client-streaming call and returns a stream handle.
func StreamService_ClientStreamCallStart(ctx context.Context) (uint64, error) {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		return 0, err
	}
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, protocol)
	session := rpcruntime.GetStreamSession(handle)
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}

	svc, ok := h.(StreamServiceServer)
	if !ok {
		return 0, rpcruntime.ErrHandlerTypeMismatch
	}
	adaptorStream := &streamService_ClientStreamCallServerAdaptor{session: session}
	session.SetHandlerState(adaptorStream)
	go func() {
		err := svc.ClientStreamCall(adaptorStream)
		rpcruntime.CompleteClientStream(handle, adaptorStream.lastResp, err)
	}()

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_ClientStreamCallSend sends a request message to the stream.
func StreamService_ClientStreamCallSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_ClientStreamCallFinish closes the send-side and returns the final response.
func StreamService_ClientStreamCallFinish(streamHandle uint64) (*StreamResponse, error) {
	resp, err := rpcruntime.FinishClientStream(rpcruntime.StreamHandle(streamHandle))
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, nil
	}
	return resp.(*StreamResponse), nil
}

// StreamService_ServerStreamCall calls cgotest.StreamService.ServerStreamCall via the registered handler.
//
// This is a server-streaming method. Results are delivered via callbacks:
// - onRead is called for each response message; return false to stop receiving.
// - onDone is called exactly once when the stream ends or fails.
func StreamService_ServerStreamCall(ctx context.Context, req *StreamRequest, onRead func(*StreamResponse) bool, onDone func(error)) error {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		onDone(err)
		return err
	}
	handle, _, _ := rpcruntime.AllocateStreamHandle(ctx, protocol)
	session := rpcruntime.GetStreamSession(handle)
	if session == nil {
		onDone(rpcruntime.ErrInvalidStreamHandle)
		return rpcruntime.ErrInvalidStreamHandle
	}
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)

	svc, ok := h.(StreamServiceServer)
	if !ok {
		rpcruntime.FinishStreamHandle(handle)
		onDone(rpcruntime.ErrHandlerTypeMismatch)
		return rpcruntime.ErrHandlerTypeMismatch
	}
	adaptorStream := &streamService_ServerStreamCallServerAdaptor{session: session}
	err = svc.ServerStreamCall(req, adaptorStream)
	rpcruntime.FinishStreamHandle(handle)
	onDone(err)
	return err
}

// StreamService_BidiStreamCall bidi-streaming adaptor functions.
// These use a combined staged + callback API: Start, Send, CloseSend + receive callbacks.

// StreamService_BidiStreamCallStart initializes a bidi-streaming call and returns a stream handle.
// Provide onRead and onDone callbacks to receive response messages.
func StreamService_BidiStreamCallStart(ctx context.Context, onRead func(*StreamResponse) bool, onDone func(error)) (uint64, error) {
	protocol, h, err := StreamService_lookupHandler(ctx)
	if err != nil {
		return 0, err
	}
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, protocol)
	session := rpcruntime.GetStreamSession(handle)
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)

	svc, ok := h.(StreamServiceServer)
	if !ok {
		return 0, rpcruntime.ErrHandlerTypeMismatch
	}
	adaptorStream := &streamService_BidiStreamCallServerAdaptor{session: session}
	session.SetHandlerState(adaptorStream)
	go func() {
		err := svc.BidiStreamCall(adaptorStream)
		if cb := session.OnDone(); cb != nil {
			cb(err)
		}
		rpcruntime.FinishStreamHandle(handle)
	}()

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_BidiStreamCallSend sends a request message to the stream.
func StreamService_BidiStreamCallSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_BidiStreamCallCloseSend closes the send-side of the stream.
func StreamService_BidiStreamCallCloseSend(streamHandle uint64) error {
	return rpcruntime.CloseSendCh(rpcruntime.StreamHandle(streamHandle))
}
